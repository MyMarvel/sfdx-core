{"version":3,"file":"configStore.js","sources":["../../src/config/configStore.ts"],"sourcesContent":["/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: BSD-3-Clause\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause\n */\n\nimport { AsyncCreatable, set } from '@salesforce/kit';\nimport {\n  AnyJson,\n  definiteEntriesOf,\n  definiteValuesOf,\n  Dictionary,\n  get,\n  getAnyJson,\n  JsonMap,\n  Optional\n} from '@salesforce/ts-types';\n\n/**\n * The allowed types stored in a config store.\n */\nexport type ConfigValue = AnyJson;\n\n/**\n * The type of entries in a config store defined by the key and value type of {@link ConfigContents}.\n */\nexport type ConfigEntry = [string, ConfigValue];\n\n/**\n * The type of content a config stores.\n */\nexport type ConfigContents = Dictionary<ConfigValue>;\n\n/**\n * An interface for a config object with a persistent store.\n */\nexport interface ConfigStore {\n  // Map manipulation methods\n  entries(): ConfigEntry[];\n  get(key: string): Optional<ConfigValue>;\n  getKeysByValue(value: ConfigValue): string[];\n  has(key: string): boolean;\n  keys(): string[];\n  set(key: string, value: ConfigValue): ConfigContents;\n  unset(key: string): boolean;\n  unsetAll(keys: string[]): boolean;\n  clear(): void;\n  values(): ConfigValue[];\n\n  forEach(actionFn: (key: string, value: ConfigValue) => void): void;\n  awaitEach(actionFn: (key: string, value: ConfigValue) => Promise<void>): Promise<void>;\n\n  // Content methods\n  getContents(): ConfigContents;\n  setContents(contents?: ConfigContents): void;\n}\n\n/**\n * An abstract class that implements all the config management functions but\n * none of the storage functions.\n *\n * **Note:** To see the interface, look in typescripts autocomplete help or the npm package's ConfigStore.d.ts file.\n */\nexport abstract class BaseConfigStore<T extends BaseConfigStore.Options> extends AsyncCreatable<T>\n  implements ConfigStore {\n  protected options: T;\n\n  // Initialized in setContents\n  private contents!: ConfigContents;\n\n  /**\n   * Constructor.\n   * @param options The options for the class instance.\n   * @ignore\n   */\n  public constructor(options: T) {\n    super(options);\n    this.options = options;\n    this.setContents(this.options.contents);\n  }\n\n  /**\n   * Returns an array of {@link ConfigEntry} for each element in the config.\n   */\n  public entries(): ConfigEntry[] {\n    return definiteEntriesOf(this.contents);\n  }\n\n  /**\n   * Returns the value associated to the key, or undefined if there is none.\n   * @param key The key.\n   */\n  public get(key: string): Optional<ConfigValue> {\n    return getAnyJson(this.contents, key);\n  }\n\n  /**\n   * Returns the list of keys that contain a value.\n   * @param value The value to filter keys on.\n   */\n  public getKeysByValue(value: ConfigValue): string[] {\n    const matchedEntries = this.entries().filter((entry: ConfigEntry) => entry[1] === value);\n    // Only return the keys\n    return matchedEntries.map((entry: ConfigEntry) => entry[0]);\n  }\n\n  /**\n   * Returns a boolean asserting whether a value has been associated to the key in the config object or not.\n   * @param key The key.\n   */\n  public has(key: string): boolean {\n    return !!get(this.contents, key);\n  }\n\n  /**\n   * Returns an array that contains the keys for each element in the config object.\n   */\n  public keys(): string[] {\n    return Object.keys(this.contents);\n  }\n\n  /**\n   * Sets the value for the key in the config object.\n   * @param key The Key.\n   * @param value The value.\n   */\n  public set(key: string, value: ConfigValue): ConfigContents {\n    this.setMethod(this.contents, key, value);\n    return this.contents;\n  }\n\n  /**\n   * Returns `true` if an element in the config object existed and has been removed, or `false` if the element does not\n   * exist. {@link BaseConfigStore.has} will return false afterwards.\n   * @param key The key.\n   */\n  public unset(key: string): boolean {\n    return delete this.contents[key];\n  }\n\n  /**\n   * Returns `true` if all elements in the config object existed and have been removed, or `false` if all the elements\n   * do not exist (some may have been removed). {@link BaseConfigStore.has(key)} will return false afterwards.\n   * @param keys The keys.\n   */\n  public unsetAll(keys: string[]): boolean {\n    return keys.reduce((val, key) => val && this.unset(key), true);\n  }\n\n  /**\n   * Removes all key/value pairs from the config object.\n   */\n  public clear(): void {\n    this.contents = {};\n  }\n\n  /**\n   * Returns an array that contains the values for each element in the config object.\n   */\n  public values(): ConfigValue[] {\n    return definiteValuesOf(this.contents);\n  }\n\n  /**\n   * Returns the entire config contents.\n   */\n  public getContents(): ConfigContents {\n    if (!this.contents) {\n      this.setContents();\n    }\n    return this.contents;\n  }\n\n  /**\n   * Sets the entire config contents.\n   * @param contents The contents.\n   */\n  public setContents(contents?: ConfigContents): void {\n    this.contents = contents || {};\n  }\n\n  /**\n   * Invokes `actionFn` once for each key-value pair present in the config object.\n   * @param {function} actionFn The function `(key: string, value: ConfigValue) => void` to be called for each element.\n   */\n  public forEach(actionFn: (key: string, value: ConfigValue) => void): void {\n    const entries = this.entries();\n    for (const entry of entries) {\n      actionFn(entry[0], entry[1]);\n    }\n  }\n\n  /**\n   * Asynchronously invokes `actionFn` once for each key-value pair present in the config object.\n   * @param {function} actionFn The function `(key: string, value: ConfigValue) => Promise<void>` to be called for\n   * each element.\n   * @returns {Promise<void>}\n   */\n  public async awaitEach(actionFn: (key: string, value: ConfigValue) => Promise<void>): Promise<void> {\n    const entries = this.entries();\n    for (const entry of entries) {\n      await actionFn(entry[0], entry[1]);\n    }\n  }\n\n  /**\n   * Convert the config object to a JSON object. Returns the config contents.\n   * Same as calling {@link ConfigStore.getContents}\n   */\n  public toObject(): JsonMap {\n    return this.contents;\n  }\n\n  /**\n   * Convert an object to a {@link ConfigContents} and set it as the config contents.\n   * @param obj The object.\n   */\n  public setContentsFromObject<U extends object>(obj: U): void {\n    this.contents = {};\n    Object.entries(obj).forEach(([key, value]) => {\n      this.setMethod(this.contents, key, value);\n    });\n  }\n\n  // Allows extended classes the ability to override the set method. i.e. maybe they don't want\n  // nested object set from kit.\n  protected setMethod(contents: ConfigContents, key: string, value?: ConfigValue) {\n    set(contents, key, value);\n  }\n}\n\n/**\n * @ignore\n */\nexport namespace BaseConfigStore {\n  /**\n   * Options for the config store.\n   */\n  export interface Options {\n    /**\n     * Intial contents for the config.\n     */\n    contents?: ConfigContents;\n  }\n}\n"],"names":["AsyncCreatable","definiteEntriesOf","getAnyJson","get","definiteValuesOf","set"],"mappings":"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"}
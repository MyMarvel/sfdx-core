{"version":3,"file":"configFile.js","sources":["../../src/config/configFile.ts"],"sourcesContent":["/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: BSD-3-Clause\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause\n */\n\nimport { isBoolean } from '@salesforce/ts-types';\nimport { constants as fsConstants, Stats as fsStats } from 'fs';\nimport { homedir as osHomedir } from 'os';\nimport { dirname as pathDirname, join as pathJoin } from 'path';\nimport { Global } from '../global';\nimport { Logger } from '../logger';\nimport { Messages } from '../messages';\nimport { SfdxError } from '../sfdxError';\nimport { fs } from '../util/fs';\nimport { resolveProjectPath } from '../util/internal';\nimport { BaseConfigStore, ConfigContents } from './configStore';\n\nMessages.importMessagesDirectory(pathJoin(__dirname));\n\n/**\n * Represents a json config file used to manage settings and state. Global config\n * files are stored in the home directory hidden state folder (.sfdx) and local config\n * files are stored in the project path, either in the hidden state folder or wherever\n * specified.\n *\n * ```\n * class MyConfig extends ConfigFile {\n *   public static getFileName(): string {\n *     return 'myConfigFilename.json';\n *   }\n * }\n * const myConfig = await MyConfig.create({\n *   isGlobal: true\n * });\n * myConfig.set('mykey', 'myvalue');\n * await myConfig.write();\n * ```\n */\nexport class ConfigFile<T extends ConfigFile.Options> extends BaseConfigStore<T> {\n  /**\n   * Returns the config's filename.\n   */\n  public static getFileName(): string {\n    // Can not have abstract static methods, so throw a runtime error.\n    throw new SfdxError('Unknown filename for config file.');\n  }\n\n  /**\n   * Returns the default options for the config file.\n   * @param isGlobal If the file should be stored globally or locally.\n   * @param filename The name of the config file.\n   */\n  public static getDefaultOptions(isGlobal = false, filename?: string): ConfigFile.Options {\n    return {\n      isGlobal,\n      isState: true,\n      filename: filename || this.getFileName()\n    };\n  }\n\n  /**\n   * Helper used to determined what the local and global folder point to. Returns the file path of the root folder.\n   *\n   * @param isGlobal True if the config should be global. False for local.\n   */\n  public static async resolveRootFolder(isGlobal: boolean): Promise<string> {\n    if (!isBoolean(isGlobal)) {\n      throw new SfdxError('isGlobal must be a boolean', 'InvalidTypeForIsGlobal');\n    }\n    return isGlobal ? osHomedir() : await resolveProjectPath();\n  }\n\n  // whether file contents have been read\n  protected hasRead = false;\n\n  // Initialized in init\n  protected logger!: Logger;\n  protected messages!: Messages;\n\n  // Initialized in create\n  private path!: string;\n\n  /**\n   * Constructor\n   * **Do not directly construct instances of this class -- use {@link ConfigFile.create} instead.**\n   * @param options The options for the class instance\n   * @ignore\n   */\n  public constructor(options: T) {\n    super(options);\n  }\n\n  /**\n   * Determines if the config file is read/write accessible. Returns `true` if the user has capabilities specified\n   * by perm.\n   * @param {number} perm The permission.\n   *\n   * **See** {@link https://nodejs.org/dist/latest/docs/api/fs.html#fs_fs_access_path_mode_callback}\n   */\n  public async access(perm: number): Promise<boolean> {\n    try {\n      await fs.access(this.getPath(), perm);\n      return true;\n    } catch (err) {\n      return false;\n    }\n  }\n\n  /**\n   * Read the config file and set the config contents. Returns the config contents of the config file. As an\n   * optimization, files are only read once per process and updated in memory and via `write()`. To force\n   * a read from the filesystem pass `force=true`.\n   * **Throws** *{@link SfdxError}{ name: 'UnexpectedJsonFileFormat' }* There was a problem reading or parsing the file.\n   * @param [throwOnNotFound = false] Optionally indicate if a throw should occur on file read.\n   * @param [force = true] Optionally force the file to be read from disk even when already read within the process.\n   */\n  public async read(throwOnNotFound = false, force = true): Promise<ConfigContents> {\n    try {\n      // Only need to read config files once.  They are kept up to date\n      // internally and updated persistently via write().\n      if (!this.hasRead || force) {\n        this.logger.info(`Reading config file: ${this.getPath()}`);\n        const obj = await fs.readJsonMap(this.getPath());\n        this.setContentsFromObject(obj);\n      }\n      return this.getContents();\n    } catch (err) {\n      if (err.code === 'ENOENT') {\n        if (!throwOnNotFound) {\n          this.setContents();\n          return this.getContents();\n        }\n      }\n      throw err;\n    } finally {\n      // Necessarily set this even when an error happens to avoid infinite re-reading.\n      // To attempt another read, pass `force=true`.\n      this.hasRead = true;\n    }\n  }\n\n  /**\n   * Write the config file with new contents. If no new contents are provided it will write the existing config\n   * contents that were set from {@link ConfigFile.read}, or an empty file if {@link ConfigFile.read} was not called.\n   *\n   * @param newContents The new contents of the file.\n   */\n  public async write(newContents?: ConfigContents): Promise<ConfigContents> {\n    if (newContents != null) {\n      this.setContents(newContents);\n    }\n\n    await fs.mkdirp(pathDirname(this.getPath()));\n\n    this.logger.info(`Writing to config file: ${this.getPath()}`);\n    await fs.writeJson(this.getPath(), this.toObject());\n\n    return this.getContents();\n  }\n\n  /**\n   * Check to see if the config file exists. Returns `true` if the config file exists and has access, false otherwise.\n   */\n  public async exists(): Promise<boolean> {\n    return await this.access(fsConstants.R_OK);\n  }\n\n  /**\n   * Get the stats of the file. Returns the stats of the file.\n   *\n   * {@link fs.stat}\n   */\n  public async stat(): Promise<fsStats> {\n    return fs.stat(this.getPath());\n  }\n\n  /**\n   * Delete the config file if it exists. Returns `true` if the file was deleted, `false` otherwise.\n   *\n   * {@link fs.unlink}\n   */\n  public async unlink(): Promise<void> {\n    const exists = await this.exists();\n    if (exists) {\n      return await fs.unlink(this.getPath());\n    }\n    throw new SfdxError(`Target file doesn't exist. path: ${this.getPath()}`, 'TargetFileNotFound');\n  }\n\n  /**\n   * Returns the path to the config file.\n   */\n  public getPath(): string {\n    return this.path;\n  }\n\n  /**\n   * Returns `true` if this config is using the global path, `false` otherwise.\n   */\n  public isGlobal(): boolean {\n    return !!this.options.isGlobal;\n  }\n\n  /**\n   * Used to initialize asynchronous components.\n   *\n   * **Throws** *`Error`{ code: 'ENOENT' }* If the {@link ConfigFile.getFilename} file is not found when\n   * options.throwOnNotFound is true.\n   */\n  protected async init(): Promise<void> {\n    this.logger = await Logger.child(this.constructor.name);\n    const statics = this.constructor as typeof ConfigFile;\n    let defaultOptions = {};\n    try {\n      defaultOptions = statics.getDefaultOptions();\n    } catch (e) {\n      /* Some implementations don't let you call default options */\n    }\n\n    // Merge default and passed in options\n    this.options = Object.assign(defaultOptions, this.options);\n\n    if (!this.options.filename) {\n      throw new SfdxError('The ConfigOptions filename parameter is invalid.', 'InvalidParameter');\n    }\n\n    const _isGlobal: boolean = isBoolean(this.options.isGlobal) && this.options.isGlobal;\n    const _isState: boolean = isBoolean(this.options.isState) && this.options.isState;\n\n    // Don't let users store config files in homedir without being in the\n    // state folder.\n    let configRootFolder = this.options.rootFolder\n      ? this.options.rootFolder\n      : await ConfigFile.resolveRootFolder(!!this.options.isGlobal);\n\n    if (_isGlobal || _isState) {\n      configRootFolder = pathJoin(configRootFolder, Global.STATE_FOLDER);\n    }\n\n    this.messages = Messages.loadMessages('@salesforce/core', 'config');\n\n    this.path = pathJoin(configRootFolder, this.options.filePath ? this.options.filePath : '', this.options.filename);\n    await this.read(this.options.throwOnNotFound);\n  }\n}\n\nexport namespace ConfigFile {\n  /**\n   * The interface for Config options.\n   */\n  export interface Options extends BaseConfigStore.Options {\n    /**\n     * The root folder where the config file is stored.\n     */\n    rootFolder?: string;\n    /**\n     * The file name.\n     */\n    filename?: string;\n    /**\n     * If the file is in the global or project directory.\n     */\n    isGlobal?: boolean;\n    /**\n     * If the file is in the state folder or no (.sfdx).\n     */\n    isState?: boolean;\n    /**\n     * The full file path where the config file is stored.\n     */\n    filePath?: string;\n    /**\n     * Indicates if init should throw if the corresponding config file is not found.\n     */\n    throwOnNotFound?: boolean;\n  }\n}\n"],"names":["Messages","pathJoin","BaseConfigStore","SfdxError","isBoolean","osHomedir","resolveProjectPath","fs","pathDirname","fsConstants","Logger","Global"],"mappings":"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"}
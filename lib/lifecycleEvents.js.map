{"version":3,"file":"lifecycleEvents.js","sources":["../src/lifecycleEvents.ts"],"sourcesContent":["/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: BSD-3-Clause\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause\n */\n\nimport { AnyJson, Dictionary } from '@salesforce/ts-types';\nimport * as Debug from 'debug';\n\n// Data of any type can be passed to the callback. Can be cast to any type that is given in emit().\n// tslint:disable-next-line:no-any\ntype callback = (data: any) => Promise<void>;\n\n/**\n * An asynchronous event listener and emitter that follows the singleton pattern. The singleton pattern allows lifecycle\n * events to be emitted from deep within a library and still be consumed by any other library or tool. It allows other\n * developers to react to certain situations or events in your library without them having to manually call the method themselves.\n *\n * An example might be transforming metadata before it is deployed to an environment. As long as an event was emitted from the\n * deploy library and you were listening on that event in the same process, you could transform the metadata before the deploy\n * regardless of where in the code that metadata was initiated.\n *\n * @example\n * ```\n * // Listen for an event in a plugin hook\n * Lifecycle.getInstance().on('deploy-metadata', transformMetadata)\n *\n * // Deep in the deploy code, fire the event for all libraries and plugins to hear.\n * Lifecycle.getInstance().emit('deploy-metadata', metadataToBeDeployed);\n * ```\n */\nexport class Lifecycle {\n  /**\n   * Retrieve the singleton instance of this class so that all listeners and emitters can interact from any library or tool\n   */\n  public static getInstance(): Lifecycle {\n    if (!this.instance) {\n      this.instance = new Lifecycle();\n    }\n    return this.instance;\n  }\n\n  private static instance: Lifecycle;\n  private debug = Debug(`sfdx:${this.constructor.name}`);\n  private listeners: Dictionary<callback[]>;\n\n  private constructor() {\n    this.listeners = {};\n  }\n\n  /**\n   * Remove all listeners for a given event\n   * @param eventName The name of the event to remove listeners of\n   */\n  public removeAllListeners(eventName: string) {\n    this.listeners[eventName] = [];\n  }\n\n  /**\n   * Get an array of listeners (callback functions) for a given event\n   * @param eventName The name of the event to get listeners of\n   */\n  public getListeners(eventName: string): callback[] {\n    const listeners = this.listeners[eventName];\n    if (listeners) {\n      return listeners;\n    } else {\n      this.listeners[eventName] = [];\n      return [];\n    }\n  }\n\n  /**\n   * Create a new listener for a given event\n   * @param eventName The name of the event that is being listened for\n   * @param cb The callback function to run when the event is emitted\n   */\n  public on<T = AnyJson>(eventName: string, cb: (data: T) => Promise<void>) {\n    const listeners = this.getListeners(eventName);\n    if (listeners.length !== 0) {\n      this.debug(\n        `${listeners.length +\n          1} lifecycle events with the name ${eventName} have now been registered. When this event is emitted all ${listeners.length +\n          1} listeners will fire.`\n      );\n    }\n    listeners.push(cb);\n    this.listeners[eventName] = listeners;\n  }\n\n  /**\n   * Emit a given event, causing all callback functions to be run in the order they were registered\n   * @param eventName The name of the event to emit\n   * @param data The argument to be passed to the callback function\n   */\n  public async emit<T = AnyJson>(eventName: string, data: T) {\n    const listeners = this.getListeners(eventName);\n    if (listeners.length === 0) {\n      this.debug(\n        `A lifecycle event with the name ${eventName} does not exist. An event must be registered before it can be emitted.`\n      );\n    } else {\n      for (const cb of listeners) {\n        await cb(data);\n      }\n    }\n  }\n}\n"],"names":["Debug"],"mappings":";;;;;;;;;;AAAA;;;;;;AAcA;;;;;;;;;;;;;;;;;;MAkBa,SAAS;IAepB;QAHQ,UAAK,GAAGA,WAAK,CAAC,QAAQ,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,CAAC,CAAC;QAIrD,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;KACrB;;;;IAbM,OAAO,WAAW;QACvB,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;YAClB,IAAI,CAAC,QAAQ,GAAG,IAAI,SAAS,EAAE,CAAC;SACjC;QACD,OAAO,IAAI,CAAC,QAAQ,CAAC;KACtB;;;;;IAcM,kBAAkB,CAAC,SAAiB;QACzC,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC;KAChC;;;;;IAMM,YAAY,CAAC,SAAiB;QACnC,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;QAC5C,IAAI,SAAS,EAAE;YACb,OAAO,SAAS,CAAC;SAClB;aAAM;YACL,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC;YAC/B,OAAO,EAAE,CAAC;SACX;KACF;;;;;;IAOM,EAAE,CAAc,SAAiB,EAAE,EAA8B;QACtE,MAAM,SAAS,GAAG,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;QAC/C,IAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;YAC1B,IAAI,CAAC,KAAK,CACR,GAAG,SAAS,CAAC,MAAM;gBACjB,CAAC,mCAAmC,SAAS,6DAA6D,SAAS,CAAC,MAAM;gBAC1H,CAAC,uBAAuB,CAC3B,CAAC;SACH;QACD,SAAS,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;QACnB,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,GAAG,SAAS,CAAC;KACvC;;;;;;IAOM,MAAM,IAAI,CAAc,SAAiB,EAAE,IAAO;QACvD,MAAM,SAAS,GAAG,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;QAC/C,IAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;YAC1B,IAAI,CAAC,KAAK,CACR,mCAAmC,SAAS,wEAAwE,CACrH,CAAC;SACH;aAAM;YACL,KAAK,MAAM,EAAE,IAAI,SAAS,EAAE;gBAC1B,MAAM,EAAE,CAAC,IAAI,CAAC,CAAC;aAChB;SACF;KACF;;;;;"}
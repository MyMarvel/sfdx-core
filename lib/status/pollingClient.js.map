{"version":3,"file":"pollingClient.js","sources":["../../src/status/pollingClient.ts"],"sourcesContent":["/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: BSD-3-Clause\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause\n */\n\nimport { setInterval } from 'timers';\n\nimport { AsyncOptionalCreatable, Duration } from '@salesforce/kit';\nimport { AnyFunction, AnyJson, ensure, Optional } from '@salesforce/ts-types';\nimport { Logger } from '../logger';\nimport { SfdxError } from '../sfdxError';\nimport { StatusResult } from './client';\n\n/**\n * This is a polling client that can be used to poll the status of long running tasks. It can be used as a replacement\n * for Streaming when streaming topics are not available or when streaming handshakes are failing. Why wouldn't you\n * want to use this? It can impact Salesforce API usage.\n *\n * ```\n * const options: PollingClient.Options = {\n *      async poll(): Promise<StatusResult>  {\n *       return Promise.resolve({ completed: true, payload: 'Hello World' });\n *     },\n *     frequency: Duration.milliseconds(10),\n *      timeout: Duration.minutes(1)\n *   };\n * const client = await PollingClient.create(options);\n * const pollResult = await client.subscribe();\n * console.log(`pollResult: ${pollResult}`);\n * ```\n */\nexport class PollingClient extends AsyncOptionalCreatable<PollingClient.Options> {\n  protected logger!: Logger;\n\n  private options: PollingClient.Options;\n  private timeout?: NodeJS.Timer;\n  private interval?: NodeJS.Timer;\n\n  /**\n   * Constructor\n   * @param options Polling client options\n   * @ignore\n   */\n  public constructor(options?: PollingClient.Options) {\n    super(options);\n    this.options = ensure(options);\n  }\n\n  /**\n   * Asynchronous initializer.\n   */\n  public async init(): Promise<void> {\n    this.logger = await Logger.child(this.constructor.name);\n  }\n\n  /**\n   * Returns a promise to call the specified polling function using the interval and timeout specified\n   * in the polling options.\n   */\n  public subscribe(): Promise<AnyJson> {\n    // This promise is held open while setInterval tries to resolve or reject.\n    // If set interval can't do it then the timeout will reject.\n    return new Promise((resolve, reject) => {\n      // Use set interval to periodically call the polling function\n\n      // This try catch enables support for time{0} since setInterval only supports\n      // time {1}. In other words, we should call first then wait for the first interval.\n      this.doPoll()\n        .then((result: Optional<StatusResult>) => {\n          if (result && result.completed) {\n            resolve(result.payload);\n          } else {\n            this.interval = setInterval(\n              PollingClient.prototype.doPoll.bind(this, resolve, reject),\n              this.options.frequency.milliseconds\n            );\n          }\n        })\n        .catch(() => {\n          this.interval = setInterval(\n            PollingClient.prototype.doPoll.bind(this, resolve, reject),\n            this.options.frequency.milliseconds\n          );\n        });\n\n      // hard polling timeout.\n      this.timeout = setTimeout(() => {\n        this.logger.debug('Polling timed out');\n        this.clearAll();\n        // @todo should go in messages.\n        reject(new SfdxError('The client has timed out.', this.options.timeoutErrorName || 'PollingClientTimeout'));\n      }, this.options.timeout.milliseconds);\n    });\n  }\n\n  private async doPoll(resolve?: AnyFunction, reject?: AnyFunction): Promise<StatusResult | undefined> {\n    try {\n      // Poll can be an async function.\n      const sample: StatusResult = await this.options.poll();\n      if (sample.completed) {\n        this.clearAll();\n        if (resolve) {\n          resolve(sample.payload);\n        } else {\n          return sample;\n        }\n      }\n    } catch (e) {\n      this.clearAll();\n      if (reject) {\n        reject(e);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  private clearAll() {\n    if (this.interval) {\n      this.logger.debug('Clearing the polling interval');\n      clearInterval(this.interval);\n    }\n    if (this.timeout) {\n      this.logger.debug('Clearing the timeout interval');\n      clearTimeout(this.timeout);\n    }\n  }\n}\n\nexport namespace PollingClient {\n  /**\n   * Options for the polling client.\n   */\n  export interface Options {\n    /**\n     * Polling function.\n     */\n    poll: () => Promise<StatusResult>;\n    /**\n     * How frequent should the polling function be called.\n     */\n    frequency: Duration;\n    /**\n     * Hard timeout for polling.\n     */\n    timeout: Duration;\n    /**\n     * Change the name of the timeout error.\n     *\n     * ```\n     * if (err.name === 'MyChangedName) ...\n     * ```\n     */\n    timeoutErrorName?: string;\n  }\n\n  /**\n   * Default options set for polling. The default options specify a timeout of 3 minutes and polling frequency of 15\n   * seconds;\n   */\n  export class DefaultPollingOptions implements PollingClient.Options {\n    public frequency: Duration;\n    public poll: () => Promise<StatusResult>;\n    public timeout: Duration;\n\n    /**\n     * constructor\n     * @param poll The function used for polling status.\n     * {@link StatusResult}\n     */\n    constructor(poll: () => Promise<StatusResult>) {\n      this.poll = poll;\n      this.timeout = Duration.minutes(3);\n      this.frequency = Duration.seconds(15);\n    }\n  }\n}\n"],"names":["AsyncOptionalCreatable","ensure","Logger","setInterval","SfdxError","Duration"],"mappings":"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"}